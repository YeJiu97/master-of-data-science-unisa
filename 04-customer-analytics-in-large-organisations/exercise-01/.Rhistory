# 使用multinom函数拟合多项 logistic 回归模型
model <- multinom(`1. \nPlease select your preferred choice from the options provided below:\n` ~ ., data = binary_data)
colnames(cleaned_numeric_data)
# 导入 readxl 包
library(readxl)
library(dplyr)
# ================= FUll text export Xlsx =============
# 读取 Excel 文件
data <- read_excel("Full text export Clone of wangjun's project.xlsx")
# 选择数据集的前12列
selected_data <- data[, 1:12]
# 查看选择的数据集结构
str(selected_data)
# 去除包含NA的行
cleaned_data <- na.omit(selected_data)
# 查看去除NA后的数据集结构
str(cleaned_data)
# ===============  Numeric export Clone of wangjun's project ========
# 读取 Excel 文件
numeric_data <- read_excel("Numeric export Clone of wangjun's project.xlsx")
# 选择数据集的前12列
selected_numeric_data <- numeric_data[, 1:12]
# 去除包含NA的行
cleaned_numeric_data <- na.omit(selected_numeric_data)
# 查看去除NA后的数据集结构
str(cleaned_numeric_data)
# ============== Doing analysis =====================================
## ============= 转换为二进制 =================
# 将自变量转换为二进制的0和1值
binary_data <- cleaned_numeric_data %>%
mutate(
age_under_40 = ifelse(`12. Your age:` == 1, 1, 0),
age_40_to_59 = ifelse(`12. Your age:` == 2, 1, 0),
age_60_or_older = ifelse(`12. Your age:` == 3, 1, 0)
) %>%
select(-`12. Your age:`)
# 查看转换后的数据集结构
str(binary_data)
## ============
# 将因变量转换为二进制形式
binary_data <- binary_data %>%
mutate(response = ifelse("1. \nPlease select your preferred choice from the options provided below:\n" == 1, 0, 1))
# 移除原因变量的列，添加新的二进制形式的因变量列
binary_data <- binary_data %>%
select(-"1. \nPlease select your preferred choice from the options provided below:\n") %>%
rename(response = response)
# 安装并加载需要的包
library(nnet)
# 使用multinom函数拟合多项 logistic 回归模型
model <- multinom("1. \nPlease select your preferred choice from the options provided below:\n" ~ ., data = binary_data)
# 转义特殊字符并重新拟合多项 logistic 回归模型
model <- multinom(`1. \nPlease select your preferred choice from the options provided below:\n` ~ ., data = binary_data)
# 使用反引号引用包含特殊字符的列名，并重新拟合多项 logistic 回归模型
model <- multinom(`1. \nPlease select your preferred choice from the options provided below:\n` ~ ., data = binary_data)
# 查看模型摘要
summary(model)
# 导入 readxl 包
library(readxl)
library(dplyr)
# ================= FUll text export Xlsx =============
# 读取 Excel 文件
data <- read_excel("Full text export Clone of wangjun's project.xlsx")
# 选择数据集的前12列
selected_data <- data[, 1:12]
# 查看选择的数据集结构
str(selected_data)
# 去除包含NA的行
cleaned_data <- na.omit(selected_data)
# 查看去除NA后的数据集结构
str(cleaned_data)
# ===============  Numeric export Clone of wangjun's project ========
# 读取 Excel 文件
numeric_data <- read_excel("Numeric export Clone of wangjun's project.xlsx")
# 选择数据集的前12列
selected_numeric_data <- numeric_data[, 1:12]
# 去除包含NA的行
cleaned_numeric_data <- na.omit(selected_numeric_data)
# 查看去除NA后的数据集结构
str(cleaned_numeric_data)
# ============== Doing analysis =====================================
## ============= 转换为二进制 =================
# 将自变量转换为二进制的0和1值
binary_data <- cleaned_numeric_data %>%
mutate(
age_under_40 = ifelse(`12. Your age:` == 1, 1, 0),
age_40_to_59 = ifelse(`12. Your age:` == 2, 1, 0),
age_60_or_older = ifelse(`12. Your age:` == 3, 1, 0)
) %>%
select(-`12. Your age:`)
# 查看转换后的数据集结构
str(binary_data)
## ============
# 将因变量转换为二进制形式
binary_data <- binary_data %>%
mutate(response = ifelse("1.nPlease select your preferred choice from the options provided below:" == 1, 0, 1))
# 移除原因变量的列，添加新的二进制形式的因变量列
binary_data <- binary_data %>%
select(-"1. \nPlease select your preferred choice from the options provided below:\n") %>%
rename(response = response)
colnames(numeric_data)
# 导入 readxl 包
library(readxl)
library(dplyr)
# ================= FUll text export Xlsx =============
# 读取 Excel 文件
data <- read_excel("Full text export Clone of wangjun's project.xlsx")
# 选择数据集的前12列
selected_data <- data[, 1:12]
# 查看选择的数据集结构
str(selected_data)
# 去除包含NA的行
cleaned_data <- na.omit(selected_data)
# 查看去除NA后的数据集结构
str(cleaned_data)
# ===============  Numeric export Clone of wangjun's project ========
# 读取 Excel 文件
numeric_data <- read_excel("Numeric export Clone of wangjun's project.xlsx")
# 选择数据集的前12列
selected_numeric_data <- numeric_data[, 1:12]
# 去除包含NA的行
cleaned_numeric_data <- na.omit(selected_numeric_data)
# 查看去除NA后的数据集结构
str(cleaned_numeric_data)
# ============== Doing analysis =====================================
## ============= 转换为二进制 =================
# 将自变量转换为二进制的0和1值
binary_data <- cleaned_numeric_data %>%
mutate(
age_under_40 = ifelse(`12. Your age:` == 1, 1, 0),
age_40_to_59 = ifelse(`12. Your age:` == 2, 1, 0),
age_60_or_older = ifelse(`12. Your age:` == 3, 1, 0)
) %>%
select(-`12. Your age:`)
# 查看转换后的数据集结构
str(binary_data)
## ============
# 将因变量转换为二进制形式
binary_data <- binary_data %>%
mutate(response = ifelse("1. Please select your preferred choice from the options provided below:" == 1, 0, 1))
# 移除原因变量的列，添加新的二进制形式的因变量列
binary_data <- binary_data %>%
select(-"1. Please select your preferred choice from the options provided below:") %>%
rename(response = response)
# 安装并加载需要的包
library(nnet)
# 使用反引号引用包含特殊字符的列名，并重新拟合多项 logistic 回归模型
model <- multinom("1. Please select your preferred choice from the options provided below:" ~ ., data = binary_data)
# 使用multinom函数拟合多项 logistic 回归模型
model <- multinom(`1. Please select your preferred choice from the options provided below:` ~ ., data = binary_data)
colnames(cleaned_numeric_data)
# 将因变量转换为因子变量
binary_data$choice <- as.factor(binary_data$`1. Please select your preferred choice from the options provided below:`)
View(cleaned_numeric_data)
expand.grid(1:16, 1:16)
factorial(16)/(factorial(14) * factorial(2))
choose(16, 2)
t(combn(1:16, 2))
rm(list=ls())
gc()
library(support.CEs)
des1 <- rotation.design(attribute.names = list(Region = c("Reg_A", "Reg_B", "Reg_C"),
Eco = c("Conv.", "More", "Most"),
Price = c("1", "1.1", "1.2")),
nalternatives = 2, nblocks = 1)
des1
library(AlgDesign)
# 1. Prepare a full-factorial design for your factors and levels.
ffd <- gen.factorial(c(3,3,3), varNames = c("Region", "Eco", "Price"), factors = "all")
# 2. Extract 8 questions from the full-factorial design.
# There can be any number you need.
alt_des <- optFederov(~., ffd, 8)$design
# 3. Use the same function as before but with an extra parameter of the
# given design prepared on step 2.
des2 <- rotation.design(candidate.array = alt_des,
attribute.names = list(Region = c("Reg_A", "Reg_B", "Reg_C"),
Eco = c("Conv.", "More", "Most"),
Price = c("1", "1.1", "1.2")),
nalternatives = 2, nblocks = 1)
des2
questionnaire(choice.experiment.design = des1)
questionnaire(choice.experiment.design = des2)
rm(list=ls())
gc()
library(support.CEs)
des1 <- rotation.design(attribute.names = list(Region = c("Reg_A", "Reg_B", "Reg_C"),
Eco = c("Conv.", "More", "Most"),
Price = c("1", "1.1", "1.2")),
nalternatives = 2, nblocks = 1, row.renames = FALSE, randomize = TRUE, seed = 987)
questionnaire(choice.experiment.design = des1)
data("syn.res1")
syn.res1[1:3, ]
desmat1 <- make.design.matrix(choice.experiment.design = des1,
optout = TRUE, categorical.attributes = c("Region", "Eco"),
continuous.attributes = c("Price"), unlabeled = TRUE)
desmat1[1:3, ]
dataset1 <- make.dataset(respondent.dataset = syn.res1,
choice.indicators = c("q1", "q2", "q3", "q4", "q5", "q6", "q7", "q8", "q9"),
design.matrix = desmat1)
dataset1[1:10, ]
library(survival)
clogout1 <- clogit(RES ~ ASC + Reg_B + Reg_C + More + Most + More:F + Most:F + Price + strata(STR),
data = dataset1)
clogout1
gofm(clogout1)
# Calculating the marginal willingness to pay
mwtp(output = clogout1, monetary.variables = c("Price"),
nonmonetary.variables = c("Reg_B", "Reg_C", "More", "Most", "More:F", "Most:F"),
confidence.level = 0.90, seed = 987)
syn.res1
library(AlgDesign)
ffd <- gen.factorial(c(2,2,4), varNames = c("HAC", "ECO", "PRI"), factors = "all")
ffd
library(support.CEs)
des1 <- rotation.design(attribute.names = list(
Region = c('region_A', 'region_B', 'region_c'),
Eco = c('Conv', 'More', 'Most'),
Price = c('1', '1.1', '1.2')),
nalternatives = 2, nblocks = 1, row.renames = FALSE,
randomize = TRUE, seed = 987)
des1
des1_no_nblock_1 <- rotation.design(attribute.names = list(
Region = c('region_A', 'region_B', 'region_c'),
Eco = c('Conv', 'More', 'Most'),
Price = c('1', '1.1', '1.2')),
nalternatives = 2, nblocks = 1, row.renames = FALSE,
randomize = TRUE, seed = 987)
des1_no_nblock_1
des1_no_nblock_1 <- rotation.design(attribute.names = list(
Region = c('region_A', 'region_B', 'region_c'),
Eco = c('Conv', 'More', 'Most'),
Price = c('1', '1.1', '1.2')),
nalternatives = 2, row.renames = FALSE,
randomize = TRUE, seed = 987)
des1_no_nblock_1 <- rotation.design(attribute.names = list(
Region = c('region_A', 'region_B', 'region_c'),
Eco = c('Conv', 'More', 'Most'),
Price = c('1', '1.1', '1.2')),
nalternatives = 2, nblocks = 2, row.renames = FALSE,
randomize = TRUE, seed = 987)
des1_no_nblock_1 <- rotation.design(attribute.names = list(
Region = c('region_A', 'region_B', 'region_c'),
Eco = c('Conv', 'More', 'Most'),
Price = c('1', '1.1', '1.2')),
nalternatives = 2, nblocks = 3, row.renames = FALSE,
randomize = TRUE, seed = 987)
des1_no_nblock_1
questionnaire(choice.experiment.design = des1)
data("syn.res1")
syn.res1[1:3, ]
desmat1 <- make.design.matrix(choice.experiment.design = des1,
+ optout = TRUE, categorical.attributes = c("Region", "Eco"),
desmat1 <- make.design.matrix(choice.experiment.design = des1,
optout = TRUE, categorical.attributes = c("Region", "Eco"),
continuous.attributes = c("Price"), unlabeled = TRUE)
R> desmat1[1:3, ]
desmat1[1:3, ]
desmat1 <- make.design.matrix(choice.experiment.design = des1,
optout = TRUE, categorical.attributes = c("Region", "Eco"),
continuous.attributes = c("Price"), unlabeled = TRUE)
desmat1[1:3, ]
desmat1
dataset1 <- make.dataset(respondent.dataset = syn.res1,
choice.indicators = c("q1", "q2", "q3", "q4", "q5", "q6", "q7", "q8", "q9"), design.matrix = desmat1)
dataset1
dataset1
library(survival)
library(survival)
clogout1 <- clogit(RES ~ ASC + Reg_B + Reg_C + More + Most +
Price + strata(STR), data = dataset1)
dataset1
library(survival)
clogout1 <- clogit(RES ~ ASC + Reg_B + Reg_C + More + Most + Price + strata(STR), data = dataset1)
clogout1 <- clogit(RES ~ ASC + region_B + region_c + More + Most + Price + strata(STR), data = dataset1)
clogout1
library(survival)
clogout1 <- clogit(RES ~ ASC + region_B + region_c + More + Most + Price + strata(STR), data = dataset1)
clogout1
gofm(clogout1)
gofm(clogout1)
library(AlgDesign)
ffd <- gen.factorial(c(2,2,4), varNames = c("HAC", "ECO", "PRI"), factors = "all")
ffd
library(support.CEs)
des1 <- rotation.design(attribute.names = list(
Region = c('region_A', 'region_B', 'region_c'),
Eco = c('Conv', 'More', 'Most'),
Price = c('1', '1.1', '1.2')),
nalternatives = 2, nblocks = 1, row.renames = FALSE,
randomize = TRUE, seed = 987)
questionnaire(choice.experiment.design = des1)
data("syn.res1")
syn.res1[1:3, ]
desmat1 <- make.design.matrix(choice.experiment.design = des1,
optout = TRUE, categorical.attributes = c("Region", "Eco"),
continuous.attributes = c("Price"), unlabeled = TRUE)
desmat1[1:3, ]
dataset1 <- make.dataset(respondent.dataset = syn.res1,
choice.indicators = c("q1", "q2", "q3", "q4", "q5", "q6", "q7", "q8", "q9"), design.matrix = desmat1)
dataset1
library(survival)
clogout1 <- clogit(RES ~ ASC + region_B + region_c + More + Most + Price + strata(STR), data = dataset1)
gofm(clogout1)
mwtp(output = clogout1, monetary.variables = c("Price"),
nonmonetary.variables = c("Reg_B", "Reg_C", "More", "Most", "More:F",
"Most:F"), confidence.level = 0.90, seed = 987)
mwtp(output = clogout1, monetary.variables = c("Price"),
nonmonetary.variables = c("region_B", "region_c", "More", "Most", "More:F",
"Most:F"), confidence.level = 0.90, seed = 987)
mwtp(output = clogout1, monetary.variables = c("Price"),
nonmonetary.variables = c("region_B", "region_c", "More", "Most", "More:F",
"Most:F"), confidence.level = 0.90, seed = 987)
mwtp(output = clogout1, monetary.variables = c("Price"),
nonmonetary.variables = c("region_B", "region_c", "More", "Most", "More:Most"),
confidence.level = 0.90, seed = 987)
View(clogout1)
colnames(clogout1)
colnames(dataset1)
mwtp(output = clogout1, monetary.variables = c("Price"),
nonmonetary.variables = c("region_B", "region_c", "More", "Most", "More:Most"),
confidence.level = 0.90, seed = 987)
dataset1
mwtp(output = clogout1, monetary.variables = c("Price"),
nonmonetary.variables = c("region_B", "region_c", "More", "Most", "More:Most"),
confidence.level = 0.90, seed = 987)
# 获取模型系数的名称
coef_names <- names(coef(clogout1))
# 检查非货币变量的名称是否在模型系数中
nonmonetary.variables <- c("region_B", "region_c", "More", "Most", "More:Most")
nonmonetary.index <- vector("numeric", length = length(nonmonetary.variables))
for (i in seq_along(nonmonetary.variables)) {
nonmonetary.index[i] <- which(coef_names == nonmonetary.variables[i])
}
# 获取模型系数的名称
coef_names <- names(coef(clogout1))
coef_names
# 检查非货币变量的名称是否在模型系数中
nonmonetary.variables <- c("region_B", "region_c", "More", "Most", "More:Most")
nonmonetary.index <- vector("numeric", length = length(nonmonetary.variables))
for (i in seq_along(nonmonetary.variables)) {
nonmonetary.index[i] <- which(coef_names == nonmonetary.variables[i])
}
nonmonetary.variables
# 检查非货币变量的名称是否在模型系数中
nonmonetary.variables <- c("region_B", "region_c", "More", "Most", "More,Most")
nonmonetary.index <- vector("numeric", length = length(nonmonetary.variables))
for (i in seq_along(nonmonetary.variables)) {
nonmonetary.index[i] <- which(coef_names == nonmonetary.variables[i])
}
coef_names <- names(coef(clogout1))
# 检查非货币变量的名称是否在模型系数中
nonmonetary.variables <- c("region_B", "region_c", "More", "Most", "More,Most")
nonmonetary.index <- vector("numeric", length = length(nonmonetary.variables))
for (i in seq_along(nonmonetary.variables)) {
nonmonetary.index[i] <- which(coef_names == nonmonetary.variables[i])
}
# 获取模型系数的名称
coef_names <- names(coef(clogout1))
# 检查非货币变量的名称是否在模型系数中
nonmonetary.variables <- c("region_B", "region_c", "More", "Most", "More,Most")
nonmonetary.index <- vector("numeric", length = length(nonmonetary.variables))
for (i in seq_along(nonmonetary.variables)) {
index <- which(coef_names == nonmonetary.variables[i])
if (length(index) > 0) {
nonmonetary.index[i] <- index
} else {
warning(paste("Coefficient for", nonmonetary.variables[i], "not found."))
}
}
nonmonetary.index
# 获取模型系数的名称
coef_names <- names(coef(clogout1))
# 检查非货币变量的名称是否在模型系数中
nonmonetary.variables <- c("region_B", "region_c", "More", "Most", "More,Most")
nonmonetary.index <- vector("numeric", length = length(nonmonetary.variables))
for (i in seq_along(nonmonetary.variables)) {
index <- which(coef_names == nonmonetary.variables[i])
if (length(index) > 0) {
nonmonetary.index[i] <- index
} else {
warning(paste("Coefficient for", nonmonetary.variables[i], "not found."))
}
}
nonmonetary.index
# 使用 mwtp 函数计算边际意愿支付
mwtp(output = clogout1, monetary.variables = c("Price"),
nonmonetary.variables = c("region_B", "region_c", "More", "Most", "More:Most"),
confidence.level = 0.90, seed = 987)
# Factorials / Permutations / Combinations
expand.grid(1:16, 1:16)
# binom coef (n, k) =  n! / (k! * (n-k)!)
factorial(16)/(factorial(14) * factorial(2))
choose(16, 2)
t(combn(1:16, 2))
# Discrete Choice Experiment
rm(list=ls())
gc()
library(support.CEs)
# Nice and easy "lucky" design of 9 questions only
# Balanced fractional factorial design - every level appears the same number of times
des1 <- rotation.design(attribute.names = list(Region = c("Reg_A", "Reg_B", "Reg_C"),
Eco = c("Conv.", "More", "Most"),
Price = c("1", "1.1", "1.2")),
nalternatives = 2, nblocks = 1)
des1
# Assume that you want to have 8 questions only
# Unbalanced fractional factorial design tries to be as close as possible to balanced,
# however allows some levels to be more frequent than others
library(AlgDesign)
# There are three steps:
# 1. Prepare a full-factorial design for your factors and levels.
ffd <- gen.factorial(c(3,3,3), varNames = c("Region", "Eco", "Price"), factors = "all")
# 2. Extract 8 questions from the full-factorial design.
# There can be any number you need.
alt_des <- optFederov(~., ffd, 8)$design
# 3. Use the same function as before but with an extra parameter of the
# given design prepared on step 2.
des2 <- rotation.design(candidate.array = alt_des,
attribute.names = list(Region = c("Reg_A", "Reg_B", "Reg_C"),
Eco = c("Conv.", "More", "Most"),
Price = c("1", "1.1", "1.2")),
nalternatives = 2, nblocks = 1)
des2
####
# When you have experiment design file you can proceed as per class presentation.
questionnaire(choice.experiment.design = des1)
# or
questionnaire(choice.experiment.design = des2)
####
# Discrete Choice Experiment
rm(list=ls())
gc()
library(support.CEs)
des1 <- rotation.design(attribute.names = list(Region = c("Reg_A", "Reg_B", "Reg_C"),
Eco = c("Conv.", "More", "Most"),
Price = c("1", "1.1", "1.2")),
nalternatives = 2, nblocks = 1, row.renames = FALSE, randomize = TRUE, seed = 987)
questionnaire(choice.experiment.design = des1)
data("syn.res1")
syn.res1[1:3, ]
desmat1 <- make.design.matrix(choice.experiment.design = des1,
optout = TRUE, categorical.attributes = c("Region", "Eco"),
continuous.attributes = c("Price"), unlabeled = TRUE)
desmat1[1:3, ]
dataset1 <- make.dataset(respondent.dataset = syn.res1,
choice.indicators = c("q1", "q2", "q3", "q4", "q5", "q6", "q7", "q8", "q9"),
design.matrix = desmat1)
dataset1[1:10, ]
library(survival)
clogout1 <- clogit(RES ~ ASC + Reg_B + Reg_C + More + Most + More:F + Most:F + Price + strata(STR),
data = dataset1)
clogout1
gofm(clogout1)
# 使用 mwtp 函数计算边际意愿支付
mwtp(output = clogout1, monetary.variables = c("Price"),
nonmonetary.variables = c("region_B", "region_c", "More", "Most", "More:Most"),
confidence.level = 0.90, seed = 987)
View(dataset1)
colnames(dataset1)
names(clogout1)
clogout1 <-
Call:
clogit(RES ~ ASC + Reg_B + Reg_C + More + Most + More:F + Most:F + Price + strata(STR),
data = dataset1)
data("syn.res1")
syn.res1[1:3, ]
desmat1 <- make.design.matrix(choice.experiment.design = des1,
optout = TRUE, categorical.attributes = c("Region", "Eco"),
continuous.attributes = c("Price"), unlabeled = TRUE)
desmat1[1:3, ]
dataset1 <- make.dataset(respondent.dataset = syn.res1,
choice.indicators = c("q1", "q2", "q3", "q4", "q5", "q6", "q7", "q8", "q9"),
design.matrix = desmat1)
dataset1[1:10, ]
library(survival)
colnames(dataset1)
clogout1 <- clogit(RES ~ ASC + Reg_B + Reg_C + More + Most + More:F + Most:F + Price + strata(STR),
data = dataset1)
clogout1
gofm(clogout1)
# 使用 mwtp 函数计算边际意愿支付
mwtp(output = clogout1, monetary.variables = c("Price"),
nonmonetary.variables = c("Reg_B", "Reg_C", "More", "Most", "More:Most"),
confidence.level = 0.90, seed = 987)
data("syn.res1")
syn.res1[1:3, ]
desmat1 <- make.design.matrix(choice.experiment.design = des1,
optout = TRUE, categorical.attributes = c("Region", "Eco"),
continuous.attributes = c("Price"), unlabeled = TRUE)
desmat1[1:3, ]
dataset1 <- make.dataset(respondent.dataset = syn.res1,
choice.indicators = c("q1", "q2", "q3", "q4", "q5", "q6", "q7", "q8", "q9"),
design.matrix = desmat1)
dataset1[1:10, ]
library(survival)
clogout1 <- clogit(RES ~ ASC + Reg_B + Reg_C + More + Most + More:F + Most:F + Price + strata(STR),
data = dataset1)
clogout1
gofm(clogout1)
# 使用 mwtp 函数计算边际意愿支付
mwtp(output = clogout1, monetary.variables = c("Price"),
nonmonetary.variables = c("Reg_B", "Reg_C", "More", "Most", "More:Most"),
confidence.level = 0.90, seed = 987)
# 提取模型系数
coefficients <- coef(clogout1)
# 定义非货币变量
nonmonetary.variables <- c("Reg_B", "Reg_C", "More", "Most", "More:F", "Most:F")
# 提取非货币变量的系数
nonmonetary.coefficients <- coefficients[names(coefficients) %in% nonmonetary.variables]
# 计算边际意愿支付
mwtp_values <- nonmonetary.coefficients * -1
# 打印结果
print(mwtp_values)
