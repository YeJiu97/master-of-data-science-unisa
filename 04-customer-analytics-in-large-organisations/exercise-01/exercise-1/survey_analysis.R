library(support.CEs)
library(readxl)
library(survival)


# check the original survey questions generated by R code
load("Design.RData")
questionnaire(choice.experiment.design = des1)



# import survey data
survey_data <- read_excel("Numeric export Clone of wangjun's project.xlsx")
survey_data_dataframe <- as.data.frame(survey_data)
survey_data_dataframe<- survey_data_dataframe[-1,1:12]


# clean NA data
survey_data_dataframe <- na.omit(survey_data_dataframe)
# check whether NA valus is existing or not
anyNA_exists <- any(is.na(survey_data_dataframe))
if (anyNA_exists) {
  print("NA value exists")
} else {
  print("No NA Values")
}


colnames(survey_data_dataframe) <- c("q1", "q2", "q3", "q4", "q5", "q6", "q7", "q8", "q9", "gender", "type", "age")


# add ID column in to survey_data_dataframe
survey_data_dataframe$ID <- seq_along(survey_data_dataframe$q1)
survey_data_dataframe$BLOCK <- 1

# make sure ID column is the first column
survey_data_dataframe <- survey_data_dataframe[, c("ID", "BLOCK", "q1", "q2", "q3", "q4", "q5", "q6", "q7", "q8", "q9", "gender", "type", "age")]

# make a check for that
colnames(survey_data_dataframe)


# data matrix
desmat1 <- make.design.matrix(choice.experiment.design = des1, 
                              optout = TRUE,
                              categorical.attributes = c("Cuisine", "Delivery", "Distance"),
                              continuous.attributes = c("Price"), unlabeled = TRUE)

desmat1[1:3, ]


# 创建一个新的数据框，仅包含ID列和q1到q9列
# survey_data_subset <- survey_data_dataframe[, c("ID", "q1", "q2", "q3", "q4", "q5", "q6", "q7", "q8", "q9")]

# 检查新数据框的列名，确认它包含了正确的列
# colnames(survey_data_subset)


# dataset
dataset1 <- make.dataset(respondent.dataset = survey_data_dataframe,
                         choice.indicators = c("q1", "q2", "q3", "q4", "q5", "q6", "q7", "q8", "q9"),
                         design.matrix = desmat1)

dataset1


# dataset2 <- dataset1[, !colnames(dataset1) %in% c("age")]



library(survival)



clogout1 <- clogit(RES ~ ASC + Asian.Cuisine + European.Cuisine + delivery + dining.in + 
                     # delivery:gender + delivery:type + dining.in:gender + dining.in:type +
                     Price + strata(STR), 
                   data = dataset1,
                   iter.max= 100)


# 定义一个函数来实现条件 logistic 回归
conditional_logit <- function(formula, data) {
  # 转换数据框为矩阵
  X <- model.matrix(formula, data)
  y <- as.numeric(data$RES) - 1 # 将响应变量转换为二进制变量
  
  # 定义一个自定义的似然函数
  likelihood <- function(theta, X, y) {
    # 计算每个观测的对数似然
    log_likelihood <- sum(y * (X %*% theta) - log(1 + exp(X %*% theta)))
    return(-log_likelihood)
  }
  
  # 使用优化算法（例如BFGS）最小化负对数似然
  result <- optim(rep(0, ncol(X)), likelihood, X=X, y=y, hessian=TRUE)
  
  # 返回模型参数估计值和协方差矩阵
  return(list(coefficients=result$par, covariance=result$hessian))
}

# 使用自定义函数进行条件 logistic 回归
clogout2 <- conditional_logit(RES ~ ASC + Asian.Cuisine + European.Cuisine + delivery + dining.in + Price, data=dataset1)


clogout2



mwtp(output = clogout1, monetary.variables = c("Price"),
     nonmonetary.variables = c("Asian.Cuisine", "European.Cuisine", "delivery", "dining.in", "Price"), 
     confidence.level = 0.90, seed = 987)






# =======================
# 定义一个函数来实现条件 logistic 回归
conditional_logit <- function(formula, data) {
  # 转换数据框为矩阵
  X <- model.matrix(formula, data)
  y <- as.numeric(data$RES) - 1 # 将响应变量转换为二进制变量
  
  # 定义一个自定义的似然函数
  likelihood <- function(theta, X, y) {
    # 计算每个观测的对数似然
    log_likelihood <- sum(y * (X %*% theta) - log(1 + exp(X %*% theta)))
    return(-log_likelihood)
  }
  
  # 使用优化算法（例如BFGS）最小化负对数似然
  result <- optim(rep(0, ncol(X)), likelihood, X=X, y=y, hessian=TRUE)
  
  # 提取模型参数估计值
  coef <- result$par
  
  # 计算模型参数的指数形式
  exp_coef <- exp(coef)
  
  # 提取协方差矩阵
  covariance <- result$hessian
  
  # 返回模型参数估计值、指数形式和协方差矩阵
  return(list(coef=coef, exp_coef=exp_coef, covariance=covariance))
}

# 使用自定义函数进行条件 logistic 回归
clogout2 <- conditional_logit(RES ~ ASC + Asian.Cuisine + European.Cuisine + delivery + dining.in + Price, data=dataset1)

# 打印模型参数估计值和指数形式
result <- clogout2
# 打印结果表头
cat(sprintf("%-10s%-10s%-10s\n", "Variable", "coef", "exp(coef)"))

# 打印每个变量的系数和指数形式
for (i in seq_along(result$coef)) {
  cat(sprintf("%-10s%-10f%-10f\n", names(result$coef)[i], result$coef[i], result$exp_coef[i]))
}

