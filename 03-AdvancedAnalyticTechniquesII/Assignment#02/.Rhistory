knitr::opts_chunk$set(echo = TRUE)
summary(cars)
plot(pressure)
install.packages('tinytex')
tinytex::install_tinytex()
tinytex:::is_tinytex()
tinytex:::tikz_compilers()
system("pdflatex --version")
tinytex:::bin_dir()
knitr::opts_chunk$set(echo = TRUE)
# 导入数据
data <- read.csv("BRCA_RNASeqv2_top50.csv")
# 查看前几行数据，确认数据已经正确导入
head(data)
library(ggplot2)
library(visdat)
library(ggplot2)
library(visdat)
# 使用visdat进行缺失值可视化
vis_miss(data)
# 查看每列的缺失值数量
missing_values_per_column <- sapply(data, function(x) sum(is.na(x)))
# 输出每列的缺失值数量
missing_values_per_column
summary(data)
View(data)
library(pcalg)
library(pcalg)
library(pcalg)
library(pcalg)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("graph")
library(pcalg)
library(pcalg)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("RBGL")
library(pcalg)
# 去除类别变量
data_wo_class <- data[,-which(names(data) == "class")]
# 计算皮尔逊相关性
cor_matrix <- cor(data_wo_class)
# 使用PC算法
suffStat <- list(C = cor_matrix, n = nrow(data_wo_class))
alpha <- 0.05  # 置信水平
pc.fit <- pc(suffStat, indepTest = gaussCItest, alpha = alpha, labels = colnames(data_wo_class))
# 可视化结果
library(igraph)
graph <- as(pc.fit, "graphNEL")
library(pcalg)
# Assuming your data is stored in a data frame named 'gene_data'
# where rows represent samples and columns represent genes
pc_result <- pc(gene_data)
library(pcalg)
# Assuming your data is stored in a data frame named 'gene_data'
# where rows represent samples and columns represent genes
pc_result <- pc(data_wo_class)
library(pcalg)
# 去除类别变量
data_wo_class <- data[,-which(names(data) == "class")]
# 计算皮尔逊相关性
cor_matrix <- cor(data_wo_class)
# 使用PC算法
suffStat <- list(C = cor_matrix, n = nrow(data_wo_class))
alpha <- 0.05  # 置信水平
pc.fit <- pc(suffStat, indepTest = gaussCItest, alpha = alpha, labels = colnames(data_wo_class))
# 可视化结果
library(igraph)
# 将PC算法的结果转换为igraph对象
graph_igraph <- asIgraph(pc.fit)
View(data_wo_class)
library(pcalg)
# 去除类别变量
data_wo_class <- data[,-which(names(data) == "class")]
# 计算皮尔逊相关性
cor_matrix <- cor(data_wo_class)
# 使用PC算法
suffStat <- list(C = cor_matrix, n = nrow(data_wo_class))
alpha <- 0.05  # 置信水平
pc.fit <- pc(suffStat, indepTest = gaussCItest, alpha = alpha, labels = colnames(data_wo_class))
# 可视化结果
library(igraph)
# 将PC算法的结果转换为igraph对象
graph_igraph <- as.igraph(pc.fit)
install.packages("bnlearn")
library(bnlearn)
# 从数据中移除类变量
data_no_class <- data[, !(names(data) %in% c("class"))]
# 使用PC算法学习网络结构
net <- pc(data_no_class)
library(bnlearn)
# 从数据中移除类变量
data_no_class <- data[, !(names(data) %in% c("class"))]
# 设置一个p值阈值，例如0.05
p.threshold <- 0.05
# 使用PC算法学习网络结构
net <- pc(data_no_class, test = "gaussian", alpha = p.threshold)
library(bnlearn)
# 从数据中移除类变量
data_no_class <- data[, !(names(data) %in% c("class"))]
# 设置一个p值阈值
p.threshold <- 0.05
# 使用PC算法的骨架部分
skel <- skeleton(data_no_class, test = "gaussian", alpha = p.threshold)
library(bnlearn)
# 从数据中移除类变量
data_no_class <- data[, !(names(data) %in% c("class"))]
# 使用PC算法学习网络结构
net <- pc(data_no_class, p = 2) # p 是用于初步的条件独立性测试的变量集的大小。您可以根据需要调整这个值。
library(pcalg)
# 从数据中移除分类变量
data_no_class <- data[, !names(data) %in% "class"]
# 使用PC算法找到基因调控网络
suffStat <- list(C = cor(data_no_class), n = nrow(data_no_class))
pc.fit <- pc(suffStat, indepTest = gaussCItest, alpha = 0.05, labels = colnames(data_no_class))
library(qgraph)
# 可视化基因调控网络
qgraph(pc.fit@graph)
# 对数据的每一列进行标准化
data_no_class_standardized <- as.data.frame(lapply(data_no_class, scale))
# 使用PC算法找到基因调控网络
suffStat <- list(C = cor(data_no_class), n = nrow(data_no_class))
pc.fit <- pc(suffStat, indepTest = gaussCItest, alpha = 0.05, labels = colnames(data_no_class))
# 可视化基因调控网络
qgraph(pc.fit@graph)
# 对数据的每一列进行标准化
data_no_class_standardized <- as.data.frame(lapply(data_no_class, scale))
# 使用PC算法找到基因调控网络
suffStat <- list(C = cor(data_no_class_standardized), n = nrow(data_no_class))
pc.fit <- pc(suffStat, indepTest = gaussCItest, alpha = 0.05, labels = colnames(data_no_class))
# 可视化基因调控网络
qgraph(pc.fit@graph)
library(qgraph)
# 可视化基因调控网络
qgraph(pc.fit@graph)
library(qgraph)
qgraph(pc.fit@graph,  title = "Gene Regulatory Network")
library(pcalg)
# Compute the CPDAG (Completed Partially Directed Acyclic Graph) using the PC algorithm
pc.fit <- pc(suffStat = list(C = cor(data_no_class_standardized), n = nrow(data_no_class_standardized)),
indepTest = gaussCItest, alpha = 0.05)
library(pcalg)
# Compute the CPDAG (Completed Partially Directed Acyclic Graph) using the PC algorithm
pc.fit <- pc(suffStat = list(C = cor(data_no_class), n = nrow(data_no_class)),
indepTest = gaussCItest, alpha = 0.05, labels = colnames(data_no_class))
# Identify minimal sets for backdoor adjustment
adjustment.sets <- backdoor.adjustment.sets(y = "EBF1", x = colnames(data_no_class), G = pc.fit@graph)
library(pcalg)
# Compute the CPDAG (Completed Partially Directed Acyclic Graph) using the PC algorithm
pc.fit <- pc(suffStat = list(C = cor(data_no_class), n = nrow(data_no_class)),
indepTest = gaussCItest, alpha = 0.05, labels = colnames(data_no_class))
# Use the IDA method to compute causal effects
causal.effects <- ida(target = "EBF1",
X = colnames(data_no_class),
data = data_no_class,
G = pc.fit@graph)
# Estimate the CPDAG
pc.fit <- pc(suffStat = list(C = cor(data_no_class_standardized), n = nrow(data_no_class_standardized)),
indepTest = gaussCItest, alpha = 0.05)
# Estimate the CPDAG
pc.fit <- pc(suffStat = list(C = cor(data_no_class), n = nrow(data_no_class)),
indepTest = gaussCItest, alpha = 0.05, labels = colnames(data_no_class))
# Identify potential adjustment sets using the backDoor function
adj.sets <- backdoor(pc.fit@graph, response = "EBF1", exposure = colnames(data_no_class))
# Estimate the CPDAG
pc.fit <- pc(suffStat = list(C = cor(data_no_class), n = nrow(data_no_class)),
indepTest = gaussCItest, alpha = 0.05, labels = colnames(data_no_class))
# Identify potential adjustment sets using the backDoor function
adj.sets <- backDoor(pc.fit@graph, response = "EBF1", exposure = colnames(data_no_class))
pcS <- pcSelect(data_no_class[,10], data_no_class[,-10], alpha=0.05)
pcS <- pcSelect(data_no_class[,"EBF1"], data_no_class[,-10], alpha=0.05)
data_no_class[,"EBF1"]
pcS <- pcSelect(data_no_class[,"EBF1"], data_no_class[,-"EBF1"], alpha=0.05)
pcS <- pcSelect(data_no_class[,"EBF1"], data_no_class[,-which("EBF1")], alpha=0.05)
pcS <- pcSelect(data_no_class[,"EBF1"], data_no_class[,!colnames(data_no_class) %in% "EBF1"], alpha=0.05)
View(pcS)
# 使用pcSelect算法
suffStat <- list(C = cor(data_no_class), n = nrow(data_no_class))
selected <- pcSelect(suffStat, target = "EBF1", alpha = 0.05)
# Construct the causal graph using the PC algorithm
suffStat <- list(C = cor(data_no_class), n = nrow(data_no_class))
pc.fit <- pc(suffStat, indepTest = gaussCItest, alpha = 0.05)
# Construct the causal graph using the PC algorithm
suffStat <- list(C = cor(data_no_class), n = nrow(data_no_class))
pc.fit <- pc(suffStat, indepTest = gaussCItest, alpha = 0.05, labels = colnames(data_no_class))
# Get adjacency matrix
adj_matrix <- pc.fit@graph
# Get indices of genes that have a connection to EBF1
ebf1_connections <- which(adj_matrix["EBF1", ] != 0 | adj_matrix[, "EBF1"] != 0)
n <- 10000
d.mat <- rmvDAG(n, pc.fit, errDist = "normal")
n <- 10000
d.mat <- rmvDAG(n, pc.fit@graph, errDist = "normal")
# Construct the causal graph using the PC algorithm
suffStat <- list(C = cor(data_no_class), n = nrow(data_no_class))
pc.fit <- pc(suffStat, indepTest = gaussCItest, alpha = 0.05, labels = colnames(data_no_class))
# Get adjacency matrix
adj_matrix <- am(pc.fit)
# Construct the causal graph using the PC algorithm
suffStat <- list(C = cor(data_no_class), n = nrow(data_no_class))
pc.fit <- pc(suffStat, indepTest = gaussCItest, alpha = 0.05, labels = colnames(data_no_class))
# Get adjacency matrix
adj_matrix <- as(pc.fit$graph, "matrix")
n <- 10000
d.mat <- rmvDAG(n, pc.fit, errDist = "normal")
# 确保已加载必要的包
install.packages("pcalg")
library(pcalg)
# 从数据中移除分类变量并进行标准化
data_no_class_standardized <- as.data.frame(lapply(data[,-which(names(data) == "class")], scale))
# 使用PC算法找到因果网络
suffStat <- list(C = cor(data_no_class_standardized), n = nrow(data_no_class_standardized))
pc.fit <- pc(suffStat, indepTest = gaussCItest, alpha = 0.05, labels = colnames(data_no_class_standardized))
# 获取EBF1的邻居
ebf1_neighbors <- names(which(pc.fit@graph[, which(colnames(data_no_class_standardized) == "EBF1")] != 0))
# 从数据中移除分类变量并进行标准化
data_no_class_standardized <- as.data.frame(lapply(data[,-which(names(data) == "class")], scale))
# 使用PC算法找到因果网络
suffStat <- list(C = cor(data_no_class_standardized), n = nrow(data_no_class_standardized))
pc.fit <- pc(suffStat, indepTest = gaussCItest, alpha = 0.05, labels = colnames(data_no_class_standardized))
# 获取EBF1的邻居
ebf1_neighbors <- names(which(pc.fit@graph[, which(colnames(data_no_class_standardized) == "EBF1")] != 0))
# 从数据中移除分类变量并进行标准化
data_no_class_standardized <- as.data.frame(lapply(data[,-which(names(data) == "class")], scale))
# 使用PC算法找到因果网络
suffStat <- list(C = cor(data_no_class_standardized), n = nrow(data_no_class_standardized))
pc.fit <- pc(suffStat, indepTest = gaussCItest, alpha = 0.05, labels = colnames(data_no_class_standardized))
# 获取EBF1的邻居
adjMatrix <- as(pc.fit, "amat")
ebf1_index <- which(colnames(data_no_class_standardized) == "EBF1")
ebf1_neighbors <- which(adjMatrix[ebf1_index, ] != 0)
# 计算因果效应的绝对值
causal_effects <- abs(cor(data_no_class_standardized)[ebf1_neighbors, "EBF1"])
# 获取因果效应的基因名
genes_with_effects <- rownames(cor(data_no_class_standardized)[ebf1_neighbors, ])
# 将基因名与其对应的效应合并成数据框
effects_df <- data.frame(Genes = genes_with_effects, Effects = causal_effects)
# 对因果效应排序并获取前10名
top_genes <- head(effects_df[order(-effects_df$Effects),], 10)
top_genes
# 获取EBF1的邻居
adjMatrix <- as(pc.fit, "amat")
ebf1_index <- which(colnames(data_no_class_standardized) == "EBF1")
ebf1_neighbors <- which(adjMatrix[ebf1_index, ] != 0)
# 如果ebf1_neighbors的长度小于10，打印出警告信息
if(length(ebf1_neighbors) < 10){
cat("Warning: There are fewer than 10 genes directly connected to EBF1 in the causal graph.\n")
}
# 计算因果效应的绝对值
causal_effects <- abs(cor(data_no_class_standardized)[ebf1_neighbors, "EBF1"])
# 获取因果效应的基因名
genes_with_effects <- rownames(cor(data_no_class_standardized)[ebf1_neighbors, ])
# 将基因名与其对应的效应合并成数据框
effects_df <- data.frame(Genes = genes_with_effects, Effects = causal_effects)
# 对因果效应排序并获取前10名
top_genes <- head(effects_df[order(-effects_df$Effects),], 10)
top_genes
n <- 10000
d.mat <- rmvDAG(n, cpdag2dag(pc.fit), errDist = "normal")
n <- 10000
d.mat <- rmvDAG(n, pdag2dag(pc.fit), errDist = "normal")
# 获取EBF1的邻居
adjMatrix <- as(pc.fit, "amat")
ebf1_index <- which(colnames(data_no_class_standardized) == "EBF1")
ebf1_neighbors <- which(adjMatrix[ebf1_index, ] != 0)
# 如果ebf1_neighbors的长度小于10，打印出警告信息
if(length(ebf1_neighbors) < 10){
cat("Warning: There are fewer than 10 genes directly connected to EBF1 in the causal graph.\n")
}
# 计算因果效应的绝对值
causal_effects <- abs(cor(data_no_class_standardized)[ebf1_neighbors, "EBF1"])
# 获取因果效应的基因名
genes_with_effects <- rownames(cor(data_no_class_standardized)[ebf1_neighbors, ])
# 将基因名与其对应的效应合并成数据框
effects_df <- data.frame(Genes = genes_with_effects, Effects = causal_effects)
# 对因果效应排序并获取前10名
top_genes <- head(effects_df[order(-effects_df$Effects),], 10)
top_genes
n <- 10000
d.mat <- rmvDAG(n, pc.fit, errDist = "normal")
dag <- cpdag2dag(pc.fit)
View(adj_matrix)
```{R}
# 获取EBF1的邻居
adjMatrix <- as(pc.fit, "amat")
ebf1_index <- which(colnames(data_no_class_standardized) == "EBF1")
ebf1_index_row <- which(rownames(data_no_class_standardized) == "EBF1")
ebf1_neighbors <- which(adjMatrix[ebf1_index, ] != 0 | adjMatrix[,ebf1_index_row])
# 如果ebf1_neighbors的长度小于10，打印出警告信息
if(length(ebf1_neighbors) < 10){
cat("Warning: There are fewer than 10 genes directly connected to EBF1 in the causal graph.\n")
}
# 计算因果效应的绝对值
causal_effects <- abs(cor(data_no_class_standardized)[ebf1_neighbors, "EBF1"])
# 获取因果效应的基因名
genes_with_effects <- rownames(cor(data_no_class_standardized)[ebf1_neighbors, ])
# 将基因名与其对应的效应合并成数据框
effects_df <- data.frame(Genes = genes_with_effects, Effects = causal_effects)
# 对因果效应排序并获取前10名
top_genes <- head(effects_df[order(-effects_df$Effects),], 10)
top_genes
# 获取EBF1的邻居
adjMatrix <- as(pc.fit, "amat")
ebf1_index <- which(colnames(data_no_class_standardized) == "EBF1")
ebf1_index_row <- which(rownames(data_no_class_standardized) == "EBF1")
ebf1_neighbors <- which(adjMatrix[ebf1_index, ] != 0 | adjMatrix[,ebf1_index_row] != 0)
# 如果ebf1_neighbors的长度小于10，打印出警告信息
if(length(ebf1_neighbors) < 10){
cat("Warning: There are fewer than 10 genes directly connected to EBF1 in the causal graph.\n")
}
# 计算因果效应的绝对值
causal_effects <- abs(cor(data_no_class_standardized)[ebf1_neighbors, "EBF1"])
# 获取因果效应的基因名
genes_with_effects <- rownames(cor(data_no_class_standardized)[ebf1_neighbors, ])
# 将基因名与其对应的效应合并成数据框
effects_df <- data.frame(Genes = genes_with_effects, Effects = causal_effects)
# 对因果效应排序并获取前10名
top_genes <- head(effects_df[order(-effects_df$Effects),], 10)
top_genes
rownames(data_no_class_standardized) == "EBF1"
rownames(data_no_class_standardized)
library(pcalg)
data_no_class <- data[, !names(data) %in% "class"]
suffStat <- list(C = cor(data_no_class), n = nrow(data_no_class))
pc.fit <- pc(suffStat, indepTest = gaussCItest, alpha = 0.01, labels = colnames(data_no_class))
knitr::opts_chunk$set(echo = TRUE)
# import data set
data <- read.csv("BRCA_RNASeqv2_top50.csv")
# check the first 6 rows
head(data)
# View the number of missing values in each column
missing_values_per_column <- sapply(data, function(x) sum(is.na(x)))
# Output the number of missing values in each column
missing_values_per_column
summary(data)
library(pcalg)
data_no_class <- data[, !names(data) %in% "class"]
suffStat <- list(C = cor(data_no_class), n = nrow(data_no_class))
pc.fit <- pc(suffStat, indepTest = gaussCItest, alpha = 0.01, labels = colnames(data_no_class))
library(qgraph)
qgraph(pc.fit@graph,  title = "Gene Regulatory Network")
library(pcalg)
data_no_class <- data[, !names(data) %in% "class"]
suffStat <- list(C = cor(data_no_class), n = nrow(data_no_class))
pc.fit <- pc(suffStat, indepTest = gaussCItest, alpha = 0.1, labels = colnames(data_no_class))
library(qgraph)
qgraph(pc.fit@graph,  title = "Gene Regulatory Network")
# 获取EBF1的邻居
adjMatrix <- as(pc.fit, "amat")
ebf1_index <- which(colnames(data_no_class_standardized) == "EBF1")
# 获取EBF1的邻居
adjMatrix <- as(pc.fit, "amat")
ebf1_index <- which(colnames(data_no_class_standardized) == "EBF1")
# 获取EBF1的邻居
adjMatrix <- as(pc.fit, "amat")
ebf1_index <- which(colnames(data_no_class_standardized) == "EBF1")
# 获取EBF1的邻居
adjMatrix <- as(pc.fit, "amat")
ebf1_index <- which(colnames(data_no_class) == "EBF1")
# ebf1_index_row <- which(rownames(data_no_class_standardized) == "EBF1")
ebf1_neighbors <- which(adjMatrix[ebf1_index, ] != 0)
# 如果ebf1_neighbors的长度小于10，打印出警告信息
if(length(ebf1_neighbors) < 10){
cat("Warning: There are fewer than 10 genes directly connected to EBF1 in the causal graph.\n")
}
# 计算因果效应的绝对值
causal_effects <- abs(cor(data_no_class)[ebf1_neighbors, "EBF1"])
# 获取因果效应的基因名
genes_with_effects <- rownames(cor(data_no_class)[ebf1_neighbors, ])
# 将基因名与其对应的效应合并成数据框
effects_df <- data.frame(Genes = genes_with_effects, Effects = causal_effects)
# 对因果效应排序并获取前10名
top_genes <- head(effects_df[order(-effects_df$Effects),], 10)
top_genes
ida("EBF1", c("NPR1","KCNIP2"), cov(data_no_class) , pc.fit@graph)
